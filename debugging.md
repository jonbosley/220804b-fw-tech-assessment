## Debugging

> How would you go about locating the cause of a stack overflow or watchdog timer reset?

There are some different options, depending on what capabilities your hardware and software provide. For example, FreeRTOS allows for a stack overflow callback when there is a stack overflow. You could put a breakpoint in that handler and then look at the call stack. Better would be to have a logging system that was called from the stack overflow callback. However, it is important to know that when calling functions when there has been a stack overflow, you can get corrupted results. Something that we did (to minimize the number of dependencies) was to store data from critical run-time errors in a "no-init" section of RAM. This is code that doesn't get zeroed out on reset. So, you can write a signature and debug information to this "no-init" section of RAM, and then reboot. Now the stack overflow is gone, but the debugging information is available to be logged on the bootup. This doesn't work if you fully power off the device, but generally you don't get the stack overflow right as someone powers off the device. 

For a watchdog timer, some processors will provide an interrupt shortly before the reset occurs with the watchdog timer. If you have this, you can check the link register (where the function would be returning from) to get an idea of what code is running. Another note on watchdogs. If you are using a multi-threaded system, you don't just want to know if one thread is running. So you might have all threads "ping" a single "watchdog petter" thread, and if that "petter" thread doesn't get the "ping" from all monitored threads, it won't pet the hardware watchdog. If this is what you have going on, you can add logging to the "petter" thread to figure out which thread wasn't reporting.

If you don't have the stack overflow callback, it can be harder to identify which thread is causing the stack overflow in a mult-threaded environment. A stack overflow can corrupt a bunch of stuff and cause failures in seemingly random parts of the code. One way to address this is to leave unused areas of RAM between the various stack spaces, and initialize them to some know values, such as "DEADBEEF" or 0xAA. Then you can look to see where the 0xAA stuff stopped being 0xAA and became something else. Sometimes you can tell based on the data, who would have been writing it. But at least you can see which stack section was the first to start being overwritten (in case the overflow was so large as to cross over multiple stack sections).
